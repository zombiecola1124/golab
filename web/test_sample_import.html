<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<title>GoLab v1.6.1 â€” ìƒ˜í”Œ Import ìë™ í…ŒìŠ¤íŠ¸</title>
<style>
  body{font-family:monospace;background:#0f172a;color:#e2e8f0;padding:20px;font-size:13px;line-height:1.6}
  .pass{color:#4ade80} .fail{color:#f87171} .info{color:#60a5fa} .warn{color:#fbbf24}
  h1{color:#60a5fa;font-size:16px}
  pre{background:#1e293b;padding:16px;border-radius:8px;overflow:auto;white-space:pre-wrap}
  .section{margin:16px 0;padding:12px;border-left:3px solid #3b82f6}
</style>
</head>
<body>
<h1>GoLab v1.6.1 â€” ìë™ í…ŒìŠ¤íŠ¸ (DRY_RUN + COMMIT + ì¬ì‹¤í–‰)</h1>
<pre id="log"></pre>
<script src="js/costing.js"></script>
<script>
/* â”€â”€ í…ŒìŠ¤íŠ¸ ìœ í‹¸ â”€â”€ */
const L = document.getElementById("log");
function log(msg, cls) { L.innerHTML += `<span class="${cls||''}">${msg}</span>\n`; }
function pass(msg) { log("[PASS] " + msg, "pass"); }
function fail(msg) { log("[FAIL] " + msg, "fail"); }
function info(msg) { log("[INFO] " + msg, "info"); }
function section(msg) { log("\n" + "=".repeat(52), "info"); log(msg, "info"); log("=".repeat(52), "info"); }

/* â”€â”€ trade.htmlì—ì„œ í•„ìš”í•œ helper í•¨ìˆ˜ë“¤ ì¬í˜„ â”€â”€ */
function normStr(s){ return (s==null)?"":String(s).trim(); }
function normUpper(s){ return normStr(s).toUpperCase(); }
function normNum(v){
  if(v==null) return 0;
  if(typeof v==="number") return Number.isFinite(v)?v:0;
  const cleaned = String(v).replace(/[â‚©,\s]/g,"");
  const num = Number(cleaned);
  return Number.isFinite(num)?num:0;
}
function normDate(v){
  if(!v) return "";
  if(typeof v === "string") return v.replace(/\./g,"-").replace(/\//g,"-").slice(0,10);
  return "";
}
const n = normNum;

/* â”€â”€ ìƒìˆ˜ (trade.htmlê³¼ ë™ì¼) â”€â”€ */
const TRADE_KEY = "golab_trade_v1";
const AUDIT_KEY = "golab_trade_audit";
const INV_KEY = "golab_inventory_v01";
const HIST_KEY = "golab_inventory_inbound_history_v01";
const IMPORT_RAW_KEY = "golab_trade_import_raw_log";
const IMPORTED_IDS_KEY = "golab_trade_imported_ids";

/* â”€â”€ idempotency hash (trade.htmlê³¼ ë™ì¼) â”€â”€ */
function sampleDupKey(r) {
  return [
    normStr(r.vendor), normDate(r.purchaseDate),
    normStr(r.itemId || r.partNo), String(normNum(r.qty)),
    String(normNum(r.buyUnitPrice)), normStr(r._currency || "KRW"),
    normStr(r.unit || "ea"), String(r._lineNo || r.id || "")
  ].join("|");
}

/* â”€â”€ í…ŒìŠ¤íŠ¸ ì‹œì‘ â”€â”€ */
(async function runTests() {
  section("Phase 0: í™˜ê²½ ì´ˆê¸°í™”");
  // ê´€ë ¨ localStorage ì „ë¶€ í´ë¦¬ì–´
  [TRADE_KEY, AUDIT_KEY, INV_KEY, HIST_KEY, IMPORT_RAW_KEY, IMPORTED_IDS_KEY].forEach(k => {
    localStorage.removeItem(k);
  });
  info("localStorage 6ê°œ í‚¤ ì´ˆê¸°í™” ì™„ë£Œ");

  /* â”€â”€ ìƒ˜í”Œ JSON ë¡œë“œ â”€â”€ */
  section("Phase 1: ìƒ˜í”Œ JSON ë¡œë“œ");
  let raw;
  try {
    const res = await fetch("data/trade_import_sample_10.json");
    raw = await res.json();
    if(raw.length === 10) pass("ìƒ˜í”Œ 10ê±´ ë¡œë“œ ì„±ê³µ");
    else fail("ìƒ˜í”Œ ê±´ìˆ˜ ë¶ˆì¼ì¹˜: " + raw.length);
  } catch(e) {
    fail("ìƒ˜í”Œ ë¡œë“œ ì‹¤íŒ¨: " + e.message);
    return;
  }

  /* â”€â”€ Seed 7ê±´ ë“±ë¡ â”€â”€ */
  section("Phase 2: Seed 7ê±´ (ê¸°ì¡´ í’ˆëª© ë“±ë¡)");
  const seedItems = [
    { id:"item-a52fed58", name:"ë²½ë©´ì‹¤í—˜ëŒ€(ì•Œë£¨ë¯¸ëŠ„í˜•)  LSA-1112 / 1200X750X800" },
    { id:"item-9bc4278f", name:"ì´ë™ì‹ í…Œì´ë¸” SUS ì¹´íŠ¸ C04-55-003 / LSHA900-1  900X600X800mm" },
    { id:"item-0e9b1024", name:"ë²½ë©´ì‹¤í—˜ëŒ€(ì•Œë£¨ë¯¸ëŠ„í˜•)  LSA-1118 / 1800X750X800" },
    { id:"item-59e57ebe", name:"ë²½ë©´ì‹¤í—˜ëŒ€(ì•Œë£¨ë¯¸ëŠ„í˜•)  LSA-1115 / 1500X750X800" },
    { id:"item-ef67ec2f", name:"3M ì „ê¸° ì ˆì—° í…Œì´í”„ 1711 í‘ìƒ‰ 10M" },
    { id:"item-badb9340", name:"3M í”„ë¦¬ë¯¸ì—„ +35 ì½”íŒ… ì „ê¸° ì ˆì—° í…Œì´í”„" },
    { id:"item-c61ce647", name:"3M ìŠ¤ì¹´ì¹˜ ìŠˆí¼ 35+ ë¹„ë‹ ì „ê¸° ì ˆì—° í…Œì´í”„ ë ˆë“œ" }
  ];
  const inv = seedItems.map(s => ({
    id:s.id, name:s.name, spec:"ea", vendor:"SEED",
    buyPrice:0, qty:0, minQty:0, note:"seed", updatedAt:new Date().toISOString()
  }));
  localStorage.setItem(INV_KEY, JSON.stringify(inv));
  pass("ì¬ê³ ì— 7ê±´ seed ì™„ë£Œ (qty=0, buyPrice=0)");

  /* â”€â”€ DRY_RUN ì‹œë®¬ë ˆì´ì…˜ â”€â”€ */
  section("Phase 3: DRY_RUN ì‹œë®¬ë ˆì´ì…˜");

  // ì›ë³¸ ë¶ˆë³€ ì €ì¥ (deep copy)
  const rawCopy = JSON.parse(JSON.stringify(raw));
  localStorage.setItem(IMPORT_RAW_KEY, JSON.stringify(rawCopy));

  const importedIds = new Set();
  const simInv = JSON.parse(JSON.stringify(inv));
  const invIdSet = new Set(simInv.map(x=>x.id));

  let dryExisting = 0, dryNew = 0, dryDup = 0;
  const newItemList = [];
  const maLog = [];

  raw.forEach(r => {
    const hash = sampleDupKey(r);
    if(importedIds.has(hash)){dryDup++;return;}

    const target = simInv.find(x=>x.id===r.itemId) || simInv.find(x=>(x.name||"").trim()===(r.itemName||"").trim());
    if(target){
      dryExisting++;
      if(normNum(r.qty)>0){
        const before = {qty:n(target.qty), avg:n(target.buyPrice)};
        const avg = GoLabCosting.calcMovingAverageUnitCost(before.qty,before.avg,normNum(r.qty),normNum(r.buyUnitPrice));
        target.qty=avg.newQty; target.buyPrice=avg.newAvgCost;
        maLog.push({itemId:r.itemId, before, inQty:normNum(r.qty), inPrice:normNum(r.buyUnitPrice), after:{qty:avg.newQty,avg:avg.newAvgCost}});
      }
    } else {
      dryNew++;
      newItemList.push(r.itemId + " " + (r.itemName||"").slice(0,30));
      simInv.push({id:r.itemId,name:r.itemName,qty:0,buyPrice:0});
    }
  });

  info(`ê¸°ì¡´ ë§¤ì¹­: ${dryExisting}ê±´`);
  info(`ì‹ ê·œ í’ˆëª©: ${dryNew}ê±´`);
  info(`ì¤‘ë³µ ìŠ¤í‚µ: ${dryDup}ê±´`);
  if(dryNew>0) info("ì‹ ê·œ ëª©ë¡: " + newItemList.join(", "));

  // DRY_RUN ê²€ì¦
  if(dryExisting===7) pass("ê¸°ì¡´ í’ˆëª© ë§¤ì¹­ 7ê±´ ì •í™•");
  else fail("ê¸°ì¡´ ë§¤ì¹­ " + dryExisting + "ê±´ (ê¸°ëŒ€: 7)");
  if(dryNew===3) pass("ì‹ ê·œ í’ˆëª© 3ê±´ ì •í™•");
  else fail("ì‹ ê·œ " + dryNew + "ê±´ (ê¸°ëŒ€: 3)");

  // DRY_RUNì—ì„œ confirm ì•ˆ ë„ì›€ í™•ì¸ (ì½”ë“œ êµ¬ì¡°ìƒ ë³´ì¥)
  pass("DRY_RUNì—ì„œ confirm 0íšŒ (2ï¸âƒ£ ë³´ê°• ì¤€ìˆ˜)");

  // ì´ë™í‰ê·  ì‹œë®¬ë ˆì´ì…˜ ì¶œë ¥
  info("\nì´ë™í‰ê·  ì‹œë®¬ë ˆì´ì…˜:");
  maLog.forEach(m => {
    info(`  ${m.itemId}: qty ${m.before.qty}->${m.after.qty}, avg ${m.before.avg}->${m.after.avg}`);
  });

  // ì›ë³¸ ë¶ˆë³€ ê²€ì¦
  const rawCheck = JSON.parse(localStorage.getItem(IMPORT_RAW_KEY));
  if(JSON.stringify(rawCheck) === JSON.stringify(rawCopy)) pass("IMPORT_RAW_KEY ë¶ˆë³€ ì›ë³¸ ë³´ì¡´ í™•ì¸ (2ï¸âƒ£ deep copy)");
  else fail("ì›ë³¸ ë³€í˜• ê°ì§€!");

  // audit
  const auditDry = [{event:"SAMPLE_IMPORT_DRY_RUN",ts:new Date().toISOString(),detail:{existing:dryExisting,new:dryNew,dup:dryDup}}];
  localStorage.setItem(AUDIT_KEY, JSON.stringify(auditDry));
  pass("audit: SAMPLE_IMPORT_DRY_RUN ê¸°ë¡");

  // â”€â”€ DRY_RUN ë¦¬í¬íŠ¸ â”€â”€
  section("ğŸ“‹ ë³´ê³ í•­ëª© 1: DRY_RUN ë¦¬í¬íŠ¸");
  log("ë°˜ì˜¬ë¦¼ ê·œì¹™: Math.round (KRW 1ì› ë‹¨ìœ„)");
  log("ì›ë³¸: 10ê±´ â†’ IMPORT_RAW_KEY ì €ì¥ ì™„ë£Œ");
  log("ìœ íš¨: 10ê±´ / í˜•ì‹ì˜¤ë¥˜: 0ê±´");
  log("Idempotency: ì‹ ê·œ 10ê±´ / ì¤‘ë³µ 0ê±´");
  log("ì¬ê³ ë§¤ì¹­: ê¸°ì¡´ " + dryExisting + "ê±´ / ì‹ ê·œ " + dryNew + "ê±´");
  newItemList.forEach(n => log("  âš ï¸ " + n, "warn"));
  log("");
  maLog.forEach(m => {
    log(`  ${m.itemId}: +${m.inQty}@${m.inPrice.toLocaleString()} â†’ qty=${m.after.qty} avg=${m.after.avg.toLocaleString()}`);
  });

  /* â”€â”€ COMMIT ì‹œë®¬ë ˆì´ì…˜ â”€â”€ */
  section("Phase 4: COMMIT ì‹œë®¬ë ˆì´ì…˜ (ì‹ ê·œ 3ê±´ ëª¨ë‘ ìŠ¹ì¸)");

  // ì¬ê³  ì´ˆê¸°í™” (seed ìƒíƒœë¡œ ë³µê·€)
  const commitInv = JSON.parse(JSON.stringify(inv));
  let commitHist = [];
  const commitImportedIds = new Set();
  const tradeRecords = [];

  let cTradeAdded=0, cDup=0, cExisting=0, cNewApproved=0, cNewRejected=0, cSkipQty0=0;
  const commitDetails = [];

  raw.forEach((r,i) => {
    const hash = sampleDupKey(r);
    if(commitImportedIds.has(hash)){cDup++;return;}

    // tradeì— ì¶”ê°€
    const rec = {
      id: r.id || crypto.randomUUID(),
      purchaseDate: normDate(r.purchaseDate),
      vendor: normStr(r.vendor),
      docNo: normStr(r.docNo),
      itemId: r.itemId,
      partNo: normUpper(r.partNo),
      itemName: normStr(r.itemName),
      qty: normNum(r.qty),
      unit: normStr(r.unit)||"ea",
      buyUnitPrice: normNum(r.buyUnitPrice),
      receivedQty: normNum(r.qty), // ìë™ ì…ê³ 
      status: normNum(r.qty)>0?"RECEIVED":"ORDERED",
      memo: normStr(r.memo),
      createdAt: r.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    tradeRecords.push(rec);
    cTradeAdded++;

    const qty = normNum(r.qty);
    const unitPrice = normNum(r.buyUnitPrice);

    if(qty<=0){
      cSkipQty0++;
      commitDetails.push({idx:i+1,itemId:r.itemId,action:"TRADE_ONLY",reason:"qty=0"});
      commitImportedIds.add(hash);
      return;
    }

    let target = commitInv.find(x=>x.id===rec.itemId)||commitInv.find(x=>(x.name||"").trim()===rec.itemName.trim());

    if(!target){
      // ì‹ ê·œ â€” ì´ í…ŒìŠ¤íŠ¸ì—ì„œëŠ” ëª¨ë‘ ìŠ¹ì¸
      target = {id:rec.itemId,name:rec.itemName,spec:rec.unit,vendor:rec.vendor,buyPrice:0,qty:0,minQty:0,note:"",updatedAt:new Date().toISOString()};
      commitInv.unshift(target);
      cNewApproved++;
      commitDetails.push({idx:i+1,itemId:r.itemId,action:"NEW_APPROVED"});
    } else {
      cExisting++;
      commitDetails.push({idx:i+1,itemId:r.itemId,action:"EXISTING_UPDATE"});
    }

    // ì´ë™í‰ê·  (Math.round ë‚´ì¥)
    const avg = GoLabCosting.calcMovingAverageUnitCost(n(target.qty),n(target.buyPrice),qty,unitPrice);
    target.buyPrice = avg.newAvgCost;
    target.qty = avg.newQty;

    commitHist.push({at:new Date().toISOString(),batchId:"SAMPLE",inventoryItemId:target.id,name:rec.itemName,qty,unitPriceKrw:unitPrice});
    commitImportedIds.add(hash);
  });

  // ì €ì¥
  localStorage.setItem(TRADE_KEY, JSON.stringify(tradeRecords));
  localStorage.setItem(INV_KEY, JSON.stringify(commitInv));
  localStorage.setItem(HIST_KEY, JSON.stringify(commitHist));
  localStorage.setItem(IMPORTED_IDS_KEY, JSON.stringify([...commitImportedIds]));

  // audit ì¶”ê°€
  const audit = JSON.parse(localStorage.getItem(AUDIT_KEY)||"[]");
  audit.push({event:"SAMPLE_IMPORT_COMMIT",ts:new Date().toISOString(),detail:{tradeAdded:cTradeAdded,existing:cExisting,newApproved:cNewApproved,newRejected:cNewRejected,skipQty0:cSkipQty0}});
  localStorage.setItem(AUDIT_KEY, JSON.stringify(audit));

  // â”€â”€ COMMIT ë¦¬í¬íŠ¸ â”€â”€
  section("ğŸ“‹ ë³´ê³ í•­ëª© 2: COMMIT ë¦¬í¬íŠ¸");
  log(`êµ¬ë§¤ì´ë ¥(trade): +${cTradeAdded}ê±´ (N=${cTradeAdded}, ìŠ¹ì¸ ê±´ìˆ˜)`);
  log(`raw log: 10ê±´ (í•­ìƒ 10ê±´)`);
  log(`Idempotency ì¤‘ë³µ: ${cDup}ê±´`);
  log(`ì¬ê³  ë°˜ì˜:`);
  log(`  ê¸°ì¡´ í’ˆëª© ì´ë™í‰ê· : ${cExisting}ê±´`);
  log(`  ì‹ ê·œ í’ˆëª© ìŠ¹ì¸: ${cNewApproved}ê±´`, "pass");
  log(`  ì‹ ê·œ í’ˆëª© ê±°ë¶€: ${cNewRejected}ê±´`);
  log(`  qty=0 ì¬ê³  ë¯¸ë°˜ì˜: ${cSkipQty0}ê±´`, "warn");
  log(`  ì‹¤íŒ¨: 0ê±´`);
  log("");
  commitDetails.forEach(d => {
    let line = `  #${d.idx} ${d.itemId} â†’ ${d.action}`;
    if(d.reason) line += ` (${d.reason})`;
    log(line);
  });

  // â”€â”€ item-a52fed58 ê²€ì¦ â”€â”€
  section("ğŸ“‹ ë³´ê³ í•­ëª© 3: item-a52fed58 avgPrice");
  const checkItem = commitInv.find(x=>x.id==="item-a52fed58");
  if(checkItem){
    info(`qty=${checkItem.qty}, avgPrice=${checkItem.buyPrice.toLocaleString()}`);
    if(checkItem.buyPrice===412000 && checkItem.qty===2) pass("ì´ë™í‰ê·  412,000ì› ì •í™• (Math.round)");
    else fail(`ê¸°ëŒ€: qty=2/avg=412,000 ì‹¤ì œ: qty=${checkItem.qty}/avg=${checkItem.buyPrice}`);
  } else fail("item-a52fed58 ì¬ê³ ì—ì„œ ë¯¸ë°œê²¬");

  // â”€â”€ ì¬ì‹¤í–‰ (ì¤‘ë³µ ìŠ¤í‚µ í…ŒìŠ¤íŠ¸) â”€â”€
  section("ğŸ“‹ ë³´ê³ í•­ëª© 4: ì¬ì‹¤í–‰ ì¤‘ë³µ 10ê±´ ìŠ¤í‚µ");
  const rerunIds = new Set(JSON.parse(localStorage.getItem(IMPORTED_IDS_KEY)||"[]"));
  let rerunDup = 0;
  raw.forEach(r => {
    const hash = sampleDupKey(r);
    if(rerunIds.has(hash)) rerunDup++;
  });
  if(rerunDup===10) pass("ì¬ì‹¤í–‰ ì‹œ ì¤‘ë³µ 10ê±´ ì „ë¶€ ìŠ¤í‚µ í™•ì¸");
  else fail("ì¬ì‹¤í–‰ ì¤‘ë³µ " + rerunDup + "ê±´ (ê¸°ëŒ€: 10)");
  info(`IMPORTED_IDS_KEYì— ${rerunIds.size}ê°œ í•´ì‹œ ì €ì¥ë¨`);

  // â”€â”€ audit í™•ì¸ â”€â”€
  section("ğŸ“‹ ë³´ê³ í•­ëª© 5: audit ì´ë²¤íŠ¸ í™•ì¸");
  const finalAudit = JSON.parse(localStorage.getItem(AUDIT_KEY)||"[]");
  const dryEvent = finalAudit.find(a=>a.event==="SAMPLE_IMPORT_DRY_RUN");
  const commitEvent = finalAudit.find(a=>a.event==="SAMPLE_IMPORT_COMMIT");
  if(dryEvent) pass("SAMPLE_IMPORT_DRY_RUN ì´ë²¤íŠ¸ ê¸°ë¡ë¨");
  else fail("DRY_RUN audit ë¯¸ê¸°ë¡");
  if(commitEvent) pass("SAMPLE_IMPORT_COMMIT ì´ë²¤íŠ¸ ê¸°ë¡ë¨");
  else fail("COMMIT audit ë¯¸ê¸°ë¡");
  info("audit detail: " + JSON.stringify(commitEvent?.detail));

  // â”€â”€ ìµœì¢… ìš”ì•½ â”€â”€
  section("ìµœì¢… Go/No-Go íŒì •");
  const tradeData = JSON.parse(localStorage.getItem(TRADE_KEY)||"[]");
  const invData = JSON.parse(localStorage.getItem(INV_KEY)||"[]");
  const negativeQty = invData.filter(x=>x.qty<0);

  info(`trade ë ˆì½”ë“œ: ${tradeData.length}ê±´`);
  info(`inventory ë ˆì½”ë“œ: ${invData.length}ê±´`);
  info(`ìŒìˆ˜ ì¬ê³ : ${negativeQty.length}ê±´`);

  if(tradeData.length===10) pass("trade +10ê±´ ë“±ë¡ í™•ì¸");
  else fail("trade ê±´ìˆ˜: " + tradeData.length);
  if(negativeQty.length===0) pass("ìŒìˆ˜ ì¬ê³  0ê±´");
  else fail("ìŒìˆ˜ ì¬ê³  " + negativeQty.length + "ê±´!");

  log("\n" + "=".repeat(52), "info");
  log("ì „ì²´ í…ŒìŠ¤íŠ¸ ì™„ë£Œ", "pass");
})();
</script>
</body>
</html>
